/**
 * Export Stage View
 *
 * Download all project artifacts: spec PDF, PCB gerbers, enclosure STL, firmware, and complete package.
 */

import { useState } from 'react'
import { Link } from 'react-router-dom'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import {
  Download,
  FileText,
  Cpu,
  Box,
  Code,
  Package,
  ArrowRight,
  Loader2,
  Check,
  ExternalLink,
  Table,
  MessageSquare,
  Globe,
  User,
  ChevronRight,
} from 'lucide-react'
import { clsx } from 'clsx'
import JSZip from 'jszip'
import { useWorkspaceContext } from '@/components/workspace/WorkspaceLayout'
import { StageCompletionSummary } from '@/components/workspace/StageCompletionSummary'

interface ConversationMessage {
  role: string
  content: string | Array<{ type: string; text?: string }>
}

interface Conversation {
  id: string
  messagesIn: ConversationMessage[]
  messageOut: string | null
  model: string | null
  createdAt: string
  promptTokens: number | null
  completionTokens: number | null
}

interface ExportItem {
  id: string
  icon: typeof Download
  title: string
  description: string
  filename: string
  ready: boolean
  onDownload: () => Promise<void>
}

interface VisibilitySettings {
  isPublic: boolean
  showAuthor: boolean
}

async function fetchVisibility(projectId: string): Promise<VisibilitySettings> {
  const res = await fetch(`/api/projects/${projectId}/visibility`)
  if (!res.ok) throw new Error('Failed to fetch visibility')
  return res.json()
}

async function updateVisibility(
  projectId: string,
  settings: Partial<VisibilitySettings>
): Promise<VisibilitySettings> {
  const res = await fetch(`/api/projects/${projectId}/visibility`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(settings),
  })
  if (!res.ok) throw new Error('Failed to update visibility')
  return res.json()
}

export function ExportStageView() {
  const { project } = useWorkspaceContext()
  const queryClient = useQueryClient()

  const [downloading, setDownloading] = useState<string | null>(null)
  const [downloaded, setDownloaded] = useState<Set<string>>(new Set())

  // Visibility settings for gallery publishing
  const { data: visibility, isLoading: visibilityLoading } = useQuery({
    queryKey: ['visibility', project?.id],
    queryFn: () => fetchVisibility(project!.id),
    enabled: !!project?.id && project?.status === 'complete',
  })

  const visibilityMutation = useMutation({
    mutationFn: (settings: Partial<VisibilitySettings>) =>
      updateVisibility(project!.id, settings),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['visibility', project?.id] })
    },
  })

  const firmwareComplete = project?.spec?.stages?.firmware?.status === 'complete'

  // Generate spec as JSON/text
  const downloadSpec = async () => {
    if (!project?.spec) return

    const spec = project.spec
    const content = `# ${project.name || 'PHAESTUS Project'} Specification

## Overview
${project.description || 'No description provided'}

## Final Specification
${
  spec.finalSpec
    ? `
### ${spec.finalSpec.name}
${spec.finalSpec.summary}

### PCB Size
- Width: ${spec.finalSpec.pcbSize.width}mm
- Height: ${spec.finalSpec.pcbSize.height}mm

### Inputs
${spec.finalSpec.inputs.map((i) => `- ${i.type} x${i.count}${i.notes ? ` (${i.notes})` : ''}`).join('\n')}

### Outputs
${spec.finalSpec.outputs.map((o) => `- ${o.type} x${o.count}${o.notes ? ` (${o.notes})` : ''}`).join('\n')}

### Power
- Source: ${spec.finalSpec.power.source}
- Voltage: ${spec.finalSpec.power.voltage}
- Current: ${spec.finalSpec.power.current}
${spec.finalSpec.power.batteryLife ? `- Battery Life: ${spec.finalSpec.power.batteryLife}` : ''}

### Communication
- Type: ${spec.finalSpec.communication.type}
- Protocol: ${spec.finalSpec.communication.protocol}

### Enclosure
- Style: ${spec.finalSpec.enclosure.style}
- Dimensions: ${spec.finalSpec.enclosure.width} x ${spec.finalSpec.enclosure.height} x ${spec.finalSpec.enclosure.depth}mm

### Estimated BOM
| Item | Quantity | Unit Cost |
|------|----------|-----------|
${spec.finalSpec.estimatedBOM.map((b) => `| ${b.item} | ${b.quantity} | $${b.unitCost.toFixed(2)} |`).join('\n')}

**Total Estimated Cost:** $${spec.finalSpec.estimatedBOM.reduce((sum, b) => sum + b.quantity * b.unitCost, 0).toFixed(2)}
`
    : 'Final specification not yet generated'
}

## Decisions Made
${spec.decisions.map((d) => `- **${d.question}**: ${d.answer}`).join('\n') || 'No decisions recorded'}

---
Generated by PHAESTUS Hardware Design Platform
`

    const blob = new Blob([content], { type: 'text/markdown' })
    downloadBlob(blob, `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-spec.md`)
  }

  // Download enclosure OpenSCAD/STL
  const downloadEnclosure = async () => {
    if (!project?.spec?.enclosure) return

    const zip = new JSZip()

    // Add OpenSCAD source if available
    if (project.spec.enclosure.openScadCode) {
      zip.file('enclosure.scad', project.spec.enclosure.openScadCode)
    }

    // Add iterations history
    if (project.spec.enclosure.iterations?.length > 0) {
      for (let i = 0; i < project.spec.enclosure.iterations.length; i++) {
        const iter = project.spec.enclosure.iterations[i]
        zip.file(`iterations/v${i + 1}_${iter.timestamp.slice(0, 10)}.scad`, iter.openScadCode)
        if (iter.feedback) {
          zip.file(`iterations/v${i + 1}_feedback.txt`, iter.feedback)
        }
      }
    }

    // Add README
    zip.file(
      'README.md',
      `# Enclosure Files

## Files
- \`enclosure.scad\` - OpenSCAD source file

## How to Use
1. Open \`enclosure.scad\` in OpenSCAD
2. Press F5 to preview
3. Press F6 to render (may take a few minutes)
4. Export as STL: File > Export > Export as STL

## Printing Recommendations
- Material: PLA or PETG
- Layer Height: 0.2mm
- Infill: 15-20%
- Supports: Usually not needed (designed for supportless printing)

## Customization
Edit the parameters at the top of the .scad file to adjust:
- Wall thickness
- Corner radius
- PCB clearance
- Component cutout sizes
`
    )

    const blob = await zip.generateAsync({ type: 'blob' })
    downloadBlob(
      blob,
      `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-enclosure.zip`
    )
  }

  // Download BOM as CSV
  const downloadBOM = async () => {
    if (!project?.spec?.finalSpec?.estimatedBOM) return

    const bom = project.spec.finalSpec.estimatedBOM
    const headers = ['Item', 'Quantity', 'Unit Cost ($)', 'Total Cost ($)', 'Supplier', 'Part Number']

    const rows = bom.map((b) => [
      b.item,
      b.quantity.toString(),
      b.unitCost.toFixed(2),
      (b.quantity * b.unitCost).toFixed(2),
      '', // Supplier - placeholder for user to fill
      '', // Part number - placeholder for user to fill
    ])

    // Add total row
    const totalCost = bom.reduce((sum, b) => sum + b.quantity * b.unitCost, 0)
    rows.push(['', '', 'TOTAL', totalCost.toFixed(2), '', ''])

    const csv = [
      headers.join(','),
      ...rows.map((row) => row.map((cell) => `"${cell}"`).join(',')),
    ].join('\n')

    const blob = new Blob([csv], { type: 'text/csv' })
    downloadBlob(blob, `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-bom.csv`)
  }

  // Download firmware source
  const downloadFirmware = async () => {
    if (!project?.spec?.firmware?.files) return

    const zip = new JSZip()

    for (const file of project.spec.firmware.files) {
      // Map 'json' language back to .ini for platformio.ini
      const actualPath = file.path === 'platformio.ini' ? file.path : file.path
      zip.file(actualPath, file.content)
    }

    // Add README
    zip.file(
      'README.md',
      `# ${project.name || 'PHAESTUS'} Firmware

Generated by PHAESTUS Hardware Design Platform

## Building with PlatformIO

### Option 1: VS Code
1. Install [PlatformIO IDE extension](https://platformio.org/install/ide?install=vscode)
2. Open this folder in VS Code
3. Click "Build" in the PlatformIO toolbar
4. Click "Upload" to flash to your ESP32-C6

### Option 2: Command Line
\`\`\`bash
# Install PlatformIO CLI
pip install platformio

# Build
pio run

# Upload to device
pio run -t upload

# Monitor serial output
pio device monitor
\`\`\`

## Binary Output
After building, find the binary at:
\`.pio/build/esp32c6/firmware.bin\`
`
    )

    const blob = await zip.generateAsync({ type: 'blob' })
    downloadBlob(
      blob,
      `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-firmware.zip`
    )
  }

  // Download conversations as markdown
  const downloadConversations = async () => {
    if (!project?.id) return

    try {
      // Fetch all conversations for this project
      const res = await fetch(`/api/projects/${project.id}/conversations?limit=200`)
      if (!res.ok) {
        console.error('Failed to fetch conversations - may require admin access')
        return
      }

      const { conversations } = (await res.json()) as { conversations: Conversation[] }

      if (conversations.length === 0) {
        // No conversations to export
        const blob = new Blob(
          ['# Conversation History\n\nNo conversations recorded for this project.'],
          { type: 'text/markdown' }
        )
        downloadBlob(
          blob,
          `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-conversations.md`
        )
        return
      }

      // Group conversations by stage (inferred from message content)
      const grouped = groupConversationsByStage(conversations)

      // Create ZIP with separate files per stage
      const zip = new JSZip()

      for (const [stage, convos] of Object.entries(grouped)) {
        const content = formatConversationsAsMarkdown(stage, convos)
        zip.file(`${stage}-chat.md`, content)
      }

      // Add combined file
      const allContent = Object.entries(grouped)
        .map(([stage, convos]) => formatConversationsAsMarkdown(stage, convos))
        .join('\n\n---\n\n')

      zip.file(
        'all-conversations.md',
        `# Complete Conversation History\n\n${allContent}`
      )

      // Add README
      zip.file(
        'README.md',
        `# Conversation Export

This archive contains the AI conversation history for your project, organized by stage.

## Files
${Object.keys(grouped)
  .map((stage) => `- \`${stage}-chat.md\` - ${stage.charAt(0).toUpperCase() + stage.slice(1)} stage conversations`)
  .join('\n')}
- \`all-conversations.md\` - Combined view of all conversations

## Usage
These conversations document the design process and can be used for:
- Understanding design decisions
- Reproducing the design process
- Debugging issues
- Training documentation
`
      )

      const blob = await zip.generateAsync({ type: 'blob' })
      downloadBlob(
        blob,
        `${project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'}-conversations.zip`
      )
    } catch (error) {
      console.error('Failed to export conversations:', error)
    }
  }

  // Helper: Group conversations by inferred stage
  function groupConversationsByStage(conversations: Conversation[]): Record<string, Conversation[]> {
    const grouped: Record<string, Conversation[]> = {
      spec: [],
      pcb: [],
      enclosure: [],
      firmware: [],
      other: [],
    }

    for (const conv of conversations) {
      // Infer stage from message content
      const stage = inferStageFromConversation(conv)
      grouped[stage].push(conv)
    }

    // Remove empty stages
    return Object.fromEntries(
      Object.entries(grouped).filter(([, convos]) => convos.length > 0)
    )
  }

  // Helper: Infer which stage a conversation belongs to
  function inferStageFromConversation(conv: Conversation): string {
    const allText = [
      ...conv.messagesIn.map((m) =>
        typeof m.content === 'string' ? m.content : m.content.map((c) => c.text || '').join(' ')
      ),
      conv.messageOut || '',
    ]
      .join(' ')
      .toLowerCase()

    // Match keywords to stages
    if (allText.includes('feasibility') || allText.includes('refinement') || allText.includes('blueprint')) {
      return 'spec'
    }
    if (allText.includes('pcb') || allText.includes('schematic') || allText.includes('circuit')) {
      return 'pcb'
    }
    if (allText.includes('enclosure') || allText.includes('openscad') || allText.includes('stl')) {
      return 'enclosure'
    }
    if (allText.includes('firmware') || allText.includes('platformio') || allText.includes('esp32')) {
      return 'firmware'
    }

    return 'other'
  }

  // Helper: Format conversations as markdown
  function formatConversationsAsMarkdown(stage: string, conversations: Conversation[]): string {
    const stageLabel = stage.charAt(0).toUpperCase() + stage.slice(1)

    let md = `# ${stageLabel} Stage Conversations\n\n`
    md += `*${conversations.length} conversation${conversations.length !== 1 ? 's' : ''} recorded*\n\n`

    // Sort by date (oldest first for readability)
    const sorted = [...conversations].sort(
      (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    )

    for (const conv of sorted) {
      const date = new Date(conv.createdAt).toLocaleString()
      md += `---\n\n## ${date}\n\n`

      if (conv.model) {
        md += `*Model: ${conv.model}*\n\n`
      }

      // Format messages
      for (const msg of conv.messagesIn) {
        const roleLabel = msg.role === 'system' ? '**System**' : msg.role === 'user' ? '**User**' : '**Assistant**'
        const content = typeof msg.content === 'string'
          ? msg.content
          : msg.content.map((c) => c.text || '').join('\n')

        md += `${roleLabel}:\n\n${content}\n\n`
      }

      // Add response
      if (conv.messageOut) {
        md += `**Assistant**:\n\n${conv.messageOut}\n\n`
      }

      // Add token stats if available
      if (conv.promptTokens || conv.completionTokens) {
        md += `*Tokens: ${conv.promptTokens || 0} in, ${conv.completionTokens || 0} out*\n\n`
      }
    }

    return md
  }

  // Download complete package
  const downloadComplete = async () => {
    if (!project?.spec) return

    const zip = new JSZip()
    const projectSlug = project.name?.toLowerCase().replace(/\s+/g, '-') || 'project'

    // Add spec markdown
    const specContent = generateSpecMarkdown()
    zip.file(`${projectSlug}-spec.md`, specContent)

    // Add spec as JSON
    zip.file(`${projectSlug}-spec.json`, JSON.stringify(project.spec, null, 2))

    // Add BOM as CSV if available
    if (project.spec.finalSpec?.estimatedBOM?.length) {
      const bom = project.spec.finalSpec.estimatedBOM
      const headers = ['Item', 'Quantity', 'Unit Cost ($)', 'Total Cost ($)', 'Supplier', 'Part Number']
      const rows = bom.map((b) => [
        b.item,
        b.quantity.toString(),
        b.unitCost.toFixed(2),
        (b.quantity * b.unitCost).toFixed(2),
        '',
        '',
      ])
      const totalCost = bom.reduce((sum, b) => sum + b.quantity * b.unitCost, 0)
      rows.push(['', '', 'TOTAL', totalCost.toFixed(2), '', ''])
      const csv = [
        headers.join(','),
        ...rows.map((row) => row.map((cell) => `"${cell}"`).join(',')),
      ].join('\n')
      zip.file(`${projectSlug}-bom.csv`, csv)
    }

    // Add enclosure if available
    if (project.spec.enclosure?.openScadCode) {
      zip.file('enclosure/enclosure.scad', project.spec.enclosure.openScadCode)
    }

    // Add firmware if available
    if (project.spec.firmware?.files) {
      for (const file of project.spec.firmware.files) {
        zip.file(`firmware/${file.path}`, file.content)
      }
    }

    // Add master README
    zip.file(
      'README.md',
      `# ${project.name || 'PHAESTUS Project'}

${project.description || ''}

## Contents
- \`${projectSlug}-spec.md\` - Human-readable specification
- \`${projectSlug}-spec.json\` - Machine-readable specification
- \`${projectSlug}-bom.csv\` - Bill of materials for sourcing
- \`enclosure/\` - OpenSCAD enclosure files
- \`firmware/\` - ESP32-C6 firmware source

## Quick Start

### Enclosure
1. Open \`enclosure/enclosure.scad\` in OpenSCAD
2. Render (F6) and export as STL
3. 3D print with PLA/PETG

### Firmware
1. Open \`firmware/\` in PlatformIO
2. Build and upload to ESP32-C6
3. Monitor serial output for debugging

## Generated By
PHAESTUS Hardware Design Platform
https://phaestus.app
`
    )

    const blob = await zip.generateAsync({ type: 'blob' })
    downloadBlob(blob, `${projectSlug}-complete.zip`)
  }

  function generateSpecMarkdown(): string {
    const spec = project?.spec
    if (!spec) return ''

    return `# ${project?.name || 'PHAESTUS Project'} Specification

## Overview
${project?.description || 'No description provided'}

${
  spec.finalSpec
    ? `
## Final Specification

### ${spec.finalSpec.name}
${spec.finalSpec.summary}

### Hardware

#### PCB
- Size: ${spec.finalSpec.pcbSize.width}mm x ${spec.finalSpec.pcbSize.height}mm

#### Inputs
${spec.finalSpec.inputs.map((i) => `- ${i.type} x${i.count}${i.notes ? ` - ${i.notes}` : ''}`).join('\n')}

#### Outputs
${spec.finalSpec.outputs.map((o) => `- ${o.type} x${o.count}${o.notes ? ` - ${o.notes}` : ''}`).join('\n')}

#### Power
- Source: ${spec.finalSpec.power.source}
- Voltage: ${spec.finalSpec.power.voltage}
- Current: ${spec.finalSpec.power.current}
${spec.finalSpec.power.batteryLife ? `- Estimated Battery Life: ${spec.finalSpec.power.batteryLife}` : ''}

#### Communication
- Type: ${spec.finalSpec.communication.type}
- Protocol: ${spec.finalSpec.communication.protocol}

### Enclosure
- Style: ${spec.finalSpec.enclosure.style}
- Dimensions: ${spec.finalSpec.enclosure.width}mm x ${spec.finalSpec.enclosure.height}mm x ${spec.finalSpec.enclosure.depth}mm

### Bill of Materials
| Item | Qty | Unit Cost | Total |
|------|-----|-----------|-------|
${spec.finalSpec.estimatedBOM.map((b) => `| ${b.item} | ${b.quantity} | $${b.unitCost.toFixed(2)} | $${(b.quantity * b.unitCost).toFixed(2)} |`).join('\n')}
| **Total** | | | **$${spec.finalSpec.estimatedBOM.reduce((sum, b) => sum + b.quantity * b.unitCost, 0).toFixed(2)}** |
`
    : 'Final specification not yet generated'
}

## Design Decisions
${spec.decisions.length > 0 ? spec.decisions.map((d) => `### ${d.question}\n${d.answer}\n`).join('\n') : 'No decisions recorded'}

---
*Generated by PHAESTUS Hardware Design Platform*
`
  }

  function downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }

  const handleDownload = async (id: string, downloadFn: () => Promise<void>) => {
    setDownloading(id)
    try {
      await downloadFn()
      setDownloaded((prev) => new Set(prev).add(id))
    } catch (error) {
      console.error(`Download failed for ${id}:`, error)
    } finally {
      setDownloading(null)
    }
  }

  if (!firmwareComplete) {
    return (
      <div className="flex-1 flex items-center justify-center p-8">
        <div className="text-center max-w-md">
          <div className="w-16 h-16 rounded-full bg-surface-800 flex items-center justify-center mx-auto mb-4">
            <Download className="w-8 h-8 text-surface-500" strokeWidth={1.5} />
          </div>
          <h2 className="text-xl font-semibold text-steel mb-2">Export & Manufacture</h2>
          <p className="text-steel-dim mb-4">
            Complete all stages to export your design files. You'll be able to download Gerbers, STL
            files, firmware binaries, and BOM.
          </p>
          <div className="flex items-center justify-center gap-2 text-sm text-surface-500">
            <span>Complete All Stages</span>
            <ArrowRight className="w-4 h-4" />
            <span>Export Files</span>
          </div>
        </div>
      </div>
    )
  }

  const exportItems: ExportItem[] = [
    {
      id: 'spec',
      icon: FileText,
      title: 'Specification',
      description: 'Complete project specification with requirements and BOM',
      filename: 'spec.md',
      ready: !!project?.spec?.finalSpec,
      onDownload: downloadSpec,
    },
    {
      id: 'bom',
      icon: Table,
      title: 'Bill of Materials',
      description: 'Component list as CSV for sourcing',
      filename: 'bom.csv',
      ready: (project?.spec?.finalSpec?.estimatedBOM?.length ?? 0) > 0,
      onDownload: downloadBOM,
    },
    {
      id: 'gerbers',
      icon: Cpu,
      title: 'Gerber Files',
      description: 'PCB manufacturing files (Coming soon)',
      filename: 'gerbers.zip',
      ready: false, // Not yet implemented
      onDownload: async () => {}, // Placeholder
    },
    {
      id: 'enclosure',
      icon: Box,
      title: 'Enclosure Files',
      description: 'OpenSCAD source for 3D printable enclosure',
      filename: 'enclosure.zip',
      ready: !!project?.spec?.enclosure?.openScadCode,
      onDownload: downloadEnclosure,
    },
    {
      id: 'firmware',
      icon: Code,
      title: 'Firmware Source',
      description: 'ESP32-C6 PlatformIO project',
      filename: 'firmware.zip',
      ready: (project?.spec?.firmware?.files?.length ?? 0) > 0,
      onDownload: downloadFirmware,
    },
    {
      id: 'conversations',
      icon: MessageSquare,
      title: 'Chat History',
      description: 'AI conversation logs organized by stage',
      filename: 'conversations.zip',
      ready: true, // Admin only, but always show option
      onDownload: downloadConversations,
    },
    {
      id: 'complete',
      icon: Package,
      title: 'Complete Package',
      description: 'All files in a single download',
      filename: 'complete.zip',
      ready: true,
      onDownload: downloadComplete,
    },
  ]

  const spec = project?.spec

  return (
    <div className="flex-1 flex flex-col min-h-0 overflow-auto p-6">
      <div className="mb-6 flex-shrink-0">
        <h2 className="text-xl font-semibold text-steel mb-1">Export & Manufacture</h2>
        <p className="text-steel-dim text-sm">Download design files to manufacture your hardware</p>
      </div>

      {/* Previous stage summary - show firmware completion */}
      {spec?.stages?.firmware?.status === 'complete' && spec?.firmware && (
        <div className="mb-6 max-w-2xl">
          <StageCompletionSummary
            stage="firmware"
            spec={spec}
            projectId={project?.id || ''}
            isExpanded={false}
            currentStage="export"
          />
        </div>
      )}

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 max-w-2xl">
        {exportItems.map((item) => {
          const isDownloading = downloading === item.id
          const isDownloaded = downloaded.has(item.id)

          return (
            <div key={item.id} className="bg-surface-900 rounded-lg border border-surface-700 p-4">
              <div className="flex items-start gap-3">
                <div className="w-10 h-10 rounded-lg bg-surface-800 flex items-center justify-center flex-shrink-0">
                  <item.icon className="w-5 h-5 text-copper" strokeWidth={1.5} />
                </div>
                <div className="flex-1 min-w-0">
                  <h3 className="text-sm font-medium text-steel mb-0.5">{item.title}</h3>
                  <p className="text-xs text-steel-dim mb-3">{item.description}</p>
                  {item.ready ? (
                    <button
                      onClick={() => handleDownload(item.id, item.onDownload)}
                      disabled={isDownloading}
                      className={clsx(
                        'flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded transition-colors',
                        isDownloaded
                          ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30'
                          : 'text-ash bg-copper hover:bg-copper-light'
                      )}
                    >
                      {isDownloading ? (
                        <>
                          <Loader2 className="w-3.5 h-3.5 animate-spin" />
                          Preparing...
                        </>
                      ) : isDownloaded ? (
                        <>
                          <Check className="w-3.5 h-3.5" />
                          Downloaded
                        </>
                      ) : (
                        <>
                          <Download className="w-3.5 h-3.5" />
                          {item.filename}
                        </>
                      )}
                    </button>
                  ) : (
                    <span className="text-xs text-surface-500">Not yet available</span>
                  )}
                </div>
              </div>
            </div>
          )
        })}
      </div>

      {/* Gallery Publishing */}
      <div className="mt-8 max-w-2xl">
        <div className="bg-surface-900 rounded-lg border border-surface-700 p-5">
          <div className="flex items-start gap-4">
            <div className="w-10 h-10 rounded-lg bg-surface-800 flex items-center justify-center flex-shrink-0">
              <Globe className="w-5 h-5 text-copper" strokeWidth={1.5} />
            </div>
            <div className="flex-1">
              <h3 className="text-sm font-medium text-steel mb-1">Share to Gallery</h3>
              <p className="text-xs text-steel-dim mb-4">
                Make your project visible to the public. Others can view your specifications and design concepts.
              </p>

              {visibilityLoading ? (
                <div className="flex items-center gap-2 text-xs text-steel-dim">
                  <Loader2 className="w-3.5 h-3.5 animate-spin" />
                  Loading...
                </div>
              ) : (
                <div className="space-y-3">
                  {/* Publish toggle */}
                  <label className="flex items-center justify-between cursor-pointer group">
                    <div className="flex items-center gap-2">
                      <Globe className="w-4 h-4 text-steel-dim" strokeWidth={1.5} />
                      <span className="text-sm text-steel">Publish to Gallery</span>
                    </div>
                    <button
                      onClick={() => visibilityMutation.mutate({ isPublic: !visibility?.isPublic })}
                      disabled={visibilityMutation.isPending}
                      className={clsx(
                        'relative w-10 h-5 rounded-full transition-colors',
                        visibility?.isPublic ? 'bg-copper' : 'bg-surface-600'
                      )}
                    >
                      <span
                        className={clsx(
                          'absolute top-0.5 left-0.5 w-4 h-4 rounded-full bg-white transition-transform',
                          visibility?.isPublic && 'translate-x-5'
                        )}
                      />
                    </button>
                  </label>

                  {/* Author toggle (only shown when published) */}
                  {visibility?.isPublic && (
                    <label className="flex items-center justify-between cursor-pointer group">
                      <div className="flex items-center gap-2">
                        <User className="w-4 h-4 text-steel-dim" strokeWidth={1.5} />
                        <span className="text-sm text-steel">Show my username</span>
                      </div>
                      <button
                        onClick={() => visibilityMutation.mutate({ showAuthor: !visibility?.showAuthor })}
                        disabled={visibilityMutation.isPending}
                        className={clsx(
                          'relative w-10 h-5 rounded-full transition-colors',
                          visibility?.showAuthor ? 'bg-copper' : 'bg-surface-600'
                        )}
                      >
                        <span
                          className={clsx(
                            'absolute top-0.5 left-0.5 w-4 h-4 rounded-full bg-white transition-transform',
                            visibility?.showAuthor && 'translate-x-5'
                          )}
                        />
                      </button>
                    </label>
                  )}

                  {/* Link to gallery */}
                  {visibility?.isPublic && project?.id && (
                    <Link
                      to={`/gallery/${project.id}`}
                      className="inline-flex items-center gap-1.5 text-xs text-copper hover:text-copper-light transition-colors mt-2"
                    >
                      View in Gallery
                      <ChevronRight className="w-3.5 h-3.5" />
                    </Link>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* External Resources */}
      <div className="mt-8 max-w-2xl">
        <h3 className="text-sm font-medium text-steel mb-3">Manufacturing Resources</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
          <a
            href="https://jlcpcb.com"
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-3 px-4 py-3 bg-surface-900 border border-surface-700 rounded-lg hover:border-surface-600 transition-colors"
          >
            <Cpu className="w-5 h-5 text-steel-dim" strokeWidth={1.5} />
            <div className="flex-1">
              <span className="text-sm text-steel">JLCPCB</span>
              <p className="text-xs text-steel-dim">PCB manufacturing</p>
            </div>
            <ExternalLink className="w-4 h-4 text-surface-500" strokeWidth={1.5} />
          </a>
          <a
            href="https://www.pcbway.com"
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center gap-3 px-4 py-3 bg-surface-900 border border-surface-700 rounded-lg hover:border-surface-600 transition-colors"
          >
            <Cpu className="w-5 h-5 text-steel-dim" strokeWidth={1.5} />
            <div className="flex-1">
              <span className="text-sm text-steel">PCBWay</span>
              <p className="text-xs text-steel-dim">PCB manufacturing</p>
            </div>
            <ExternalLink className="w-4 h-4 text-surface-500" strokeWidth={1.5} />
          </a>
        </div>
      </div>
    </div>
  )
}
